<h1 align="center">Parallel Graph Coloring</h1>

# Introduction

In mathematics, a graph is a structure composed by a set of objects called “Vertices” and a set of links which connect pairs of these vertices called "Edges" (or "Links") which describe a relationship between the objects.
These edges may be directed or undirected, to define a unidirectional or bidirectional relationship between the nodes associated with each link. In our study we will focus only on undirected graphs (a graph with undirected links).

Graph coloring is a well-known problem in the field of discrete mathematics:
Each vertex must be assigned a label (which in the context is defined as "color").
The coloring must respect some constraints:
1. Each vertex must have a different color than the neighboring vertices (vertices with which it has an arc in common)
2. The number of distinct colors in the entire graph must be as few as possible.
   
It has been proved that this is an NP-complete problem, for which an optimal resolution would require a non-polynomial time for a deterministics.

Although the optimal solution is impractical, several algorithms have been developed to be able to reach sub-optimal solutions in much faster times.

Therefore, the goal of this project is to implement and analyze the performance in terms of time and memory of different algorithms, proposed in distributed contexts, making use of techniques to parallelize the graph coloring process.

# Overview

The project is divided into the following categories:
1. `Utils/`: A set of libraries for parallelization and benchmarks
2. `Vertex/`: It contains the data structures for the management of the Summit, with representation of the neighbors through adjacency list
3. `Graph/`: Data structures for managing the Graph, and loaders from `.gra` and `.graph` files
4. `Colors/`: Utilities for efficient management of vertex coloring (based on the boost library)
5. `Solve/`: Algorithms used for the sequential and parallel solution of the problem

## Utils

### Benchmark

This file contains a series of functions for measuring the performance in terms of time and number of colors used, for the effective control of the coloring and for printing the results generated by the different algorithms on a `.csv` file.

### Duration Logger

The class is used for measuring the time taken by the algorithm to color the graph, through

```cpp
class DurationLogger {
private:
    std::chrono::steady_clock::time_point _start;
public:
    void start();
    double stop(); //return difference between start and now in milliseconds
};
```

### Range

Class for splitting nodes into `_numSplits` parts. The class was also designed to handle edge cases as well.

### Parallel For Each

Template function that allows you to call a `F&& fn` function for each element of the vector`std :: vector <V> &vector`, considering a separation based on the `Range` class.

The `fn` function can be executed sequentially if the number of vector elements is extremely small or is executed in parallel by a number of threads defined in `numThreads`

```cpp
void parallelForEach(size_t numThreads, std::vector<V> &vector, F&& fn);
```

## Vertex

The vertex class allows us to obtain information about a vertex in the context of graph theory.
As anticipated, the neighbors of the vertex are represented through an adjacency list.
We have decided to implement the adjacency list via a vector`std::vector<int> _adjV`, since in the algorithms we implement, a sequential access is generally made to the neighbors of the vertex.
Using a vector rather than a list, we noticed that the time performance increased, probably because the adjacent nodes are allocated in contiguous chunks of memory, increasing the cache hit rate with respect to the list implementation.

Some functions are exposed, including:
1. `int getColor() const`: return `UNCOLORED (-1)`  if it has not yet been colored, otherwise the previously assigned color
2. `const std::vector<int> &getAdjV() const`: returns the adjacency list
3. `unsigned int getDegree() const`: returns the degree of the vertex, used in LDF or Luby (with the addition of a bitmap)

## Graph

### Graph

Class that allows the management of the graph. Among the most used functions:
1. `std::vector<Vertex> &getVertices()`: returns the vector of vertices related to the graph
2. `void addEdge(int v1, int v2)`: adds an edge between the vertices `v1` and `v2`
3. `bool isColored()`: returns `true` if the graph is completely colored and no node has a color equal to its neighbor
4. `void colorVertexMinimum(Vertex &v)`: colors a vertex with the first available color, considering the neighbors.

### Loaders


Functions that allow you to generate an object of type `Graph` by reading a DIMACS (`.gra`) or DIMACS-10 (`.graph`)file.

- DIMACS-10: The DIMACS-10 format is essentially an adjancency list: the i-th row contains the list of neighbor IDs. Two loaders from this file type have been implemented:
  - Sequential: the main thread reads the line from file, generates a vertex and then assigns the list of its neighbors.
  - Parallel: The main thread reads each line of the file and places it in a thread-safe queue (Jobs class). N threads read from this queue and generate the graph vertex by vertex.
  
  
- DIMACS: The DIMACS format is an adjacency list like DIMACS-10, where only higher ID are represented (the lower ones being implicit). In this case we only implemented the sequential load.

## Solve
All the classes below extend the `Solver` class, which defines an abstract`void solve (Graph &)`method, which is then defined by the underlying solvers according to the algorithms that have been proposed.

### Greedy
`Greedy` implements the simple, well-known greedy strategy described in the specifications document, and mentioned in literature in *A comparison of Parallel Graph Coloring Algorithms*, Allwright, 1995. It a sequential solution to the problem. The main idea behind is to choose a random permutation of the vertices and in sequence, assign the smallest possible color.

### Luby
`Luby` implements the algorithm from * A simple parallel algorithm for the Maximal Independent Set problem *, M. Luby, 1985.
Starting from a graph G, the algorithm is divided into two steps:
- The first one is the * Choice Step *: all the vertices with degree = 0 are added to a list of candidates. The remainder are added to the list of candidates with a probability inversely proportional to the degree.
- The second step is the * Remove edges *: if there are two vertices connected by an arc, the one with the lowest degree is discarded from the list of candidates. All candidates are removed from graph G.
The list of selected vertices is a MIS, which can be colored in parallel with a single color. At this point the algorithm restarts with the selection of a new MIS, until the complete coloring of the graph.

### Jones Plassmann
`JonesPlassmann` implements the algorithm from *A parallel graph coloring heuristic*, M. Jones and T. Plassmann, 1992. Jones' algorithm defines a total ordering on the vertices `weights`, and then colors each node for which all uncolored neighbors have a lower `weights`.

The original Jones' paper describes the algorithm in terms of messages sent between different processors (one per vertex), based on weights associated with each vertex that are calculated by the processor.
We have decided to generate the weight vector associated with the vertices sequentially and with random weights.
Vertices are initially split equally between threads. Each thread separates its vertices into border vertices (vertices that have at least with the extreme assigned to another processor) and local vertices.
At each round the fronteer vertices that have the greatest weight (`weights [v] where v represents the vertex`) among the neighbors, belonging to the other processors, still not colored, are colored.
Comparison criterion:
```cpp
v can be colored
for (auto w: adjV) {    
    if (w is not local)
        if(w is UNCOLORED
            && weights[w] > weights[v])
            v cannot be colored
}

if (v can be colored)
    color(v)
```
Once the border vertices are fully colored, each thread can independently proceed to color the local vertices. In this way the final phase of the algorithm is highly parallelized, since no synchronization between the threads is necessary.


### Largest Degree First
`LDF` implements the algorithm from *A Comparison of Parallel Graph Coloring Algorithms*, J. R. Allwright, 1995. 
The algorithm is very similar to the previous Jones Plassmann, but the comparison criterion between the nodes varies: the nodes are colored based on the degree of the vertex. If two adjacent vertices have the same degree, Jones Plassmann's criterion is used.
Comparison criterion:
```cpp
v can be colored
for (auto w: adjV) {    
    if (w is not local)    
        if(w is UNCOLORED) &&
            ((w_degree > v_degree) ||
            (w_degree == v_degree && weights[w] > weights[v]))            
            v cannot be colored
}

if (v can be colored)
    color(v)
```
With this criterion, the algorithm can achieve a lower number of colors with respect to the random one.

# Results

